var documenterSearchIndex = {"docs":
[{"location":"references/#API-References","page":"References","title":"API References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Modules = [YaoCompiler]","category":"page"},{"location":"references/#YaoCompiler.AdjointOperation","page":"References","title":"YaoCompiler.AdjointOperation","text":"AdjointOperation{P} <: Routine\n\nAn AdjointOperation is the adjoint of another Routine.\n\n\n\n\n\n","category":"type"},{"location":"references/#YaoCompiler.AnyReg","page":"References","title":"YaoCompiler.AnyReg","text":"AnyReg <: AbstractRegister{1}\n\nA place holder for registers when compilation is not register specific.\n\n\n\n\n\n","category":"type"},{"location":"references/#YaoCompiler.GenericRoutine","page":"References","title":"YaoCompiler.GenericRoutine","text":"GenericRoutine{name} <: Function\n\nA GenericRoutine cannot be directly execute on a quantum device. It is a Julia Function that returns Operation, and Operation can be executed on quanutm device.\n\nnote: Note\nAn instance of GenericRoutine should be treated like Function.\n\n\n\n\n\n","category":"type"},{"location":"references/#YaoCompiler.IntrinsicRoutine","page":"References","title":"YaoCompiler.IntrinsicRoutine","text":"abstract type IntrinsicRoutine <: Routine end\n\nIntrinsicRoutine are the routine that can be executed by the compile target that is pre-defined in the compiler.\n\n\n\n\n\n","category":"type"},{"location":"references/#YaoCompiler.NativeJuliaTarget","page":"References","title":"YaoCompiler.NativeJuliaTarget","text":"NativeJuliaTarget <: YaoCompileTarget\n\nThis target assumes one compiles to native Julia, thus the measurement type will be directly inferred from native intrinsics.\n\n\n\n\n\n","category":"type"},{"location":"references/#YaoCompiler.Operation","page":"References","title":"YaoCompiler.Operation","text":"Operation{P, Args} <: Routine\n\nAn Operation is a user defined composite routine that can be called in other Operation or execute on target device.\n\n\n\n\n\n","category":"type"},{"location":"references/#YaoCompiler.Routine","page":"References","title":"YaoCompiler.Routine","text":"abstract type Routine end\n\nThis defines operations that one can execute on a quantum device.\n\n\n\n\n\n","category":"type"},{"location":"references/#YaoCompiler.routine_stub","page":"References","title":"YaoCompiler.routine_stub","text":"routine_stub(routine, args...)\n\nA function to store the raw CodeInfo of defined routines to support multiple dispatch. We don't directly define main gate, ctrl etc. because we can't support multiple dispatch on them directly.\n\n\n\n\n\n","category":"function"},{"location":"references/#YaoCompiler.target_measure_result_type-Tuple{YaoCompileTarget, Any, Any, Any, Any, Any, Any}","page":"References","title":"YaoCompiler.target_measure_result_type","text":"target_measure_result_type(target::YaoCompileTarget[, interp::YaoInterpreter, f, fargs, argtypes, sv, max_methods])\n\nHook for handling different measurement result type. Default type is MeasureResult.\n\n\n\n\n\n","category":"method"},{"location":"references/#YaoCompiler.@barrier-Tuple{Any}","page":"References","title":"YaoCompiler.@barrier","text":"@barrier locs\n\nSyntax sugar for barrier(locs).\n\n\n\n\n\n","category":"macro"},{"location":"references/#YaoCompiler.@ctrl-Tuple{Any, Expr}","page":"References","title":"YaoCompiler.@ctrl","text":"@ctrl <ctrl_locs> <locs> => <gate>\n\nSyntax sugar for apply(gate, locs, ctrl_locs), must be used inside @device. See also @device.\n\n\n\n\n\n","category":"macro"},{"location":"references/#YaoCompiler.@device-Tuple{Any}","page":"References","title":"YaoCompiler.@device","text":"@device <function def>\n\nAnnotate a Julia function as YaoLang device kernel.\n\n\n\n\n\n","category":"macro"},{"location":"references/#YaoCompiler.@gate-Tuple{Expr}","page":"References","title":"YaoCompiler.@gate","text":"@gate <locs> => <gate>\n\nSyntax sugar for apply(gate, locs), must be used inside @device. See also @device.\n\ntips: Tips\nYou don't have to write @gate in most cases inside @device. But in case there is ambuigity, you can annotate the expression with @gate explicitly.\n\n\n\n\n\n","category":"macro"},{"location":"references/#YaoCompiler.@measure-Tuple{Any}","page":"References","title":"YaoCompiler.@measure","text":"@measure locs\n\nSyntax sugar for measure(locs).\n\n\n\n\n\n","category":"macro"},{"location":"semantics/#Semantics","page":"Semantics","title":"Semantics","text":"","category":"section"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"The semantic of YaoCompiler tries to make use of Julia semantic as much as possible so you don't feel this is not Julian. But since the quantum circuit has some special semantic that Julia expression cannot express directly, the semantic of Julia expression is extended in YaoCompiler.","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"The point of this new IR is it make use of Julia native control flow directly instead of unroll the loop and conditions into a Julia type, such as Chain, Kron, ConditionBlock in QBIR (see our previous work), which improves the performance and provide possibility of further compiler optimization by analysis done on quantum circuit and classical control flows.","category":"page"},{"location":"semantics/#Gate-Position","page":"Semantics","title":"Gate Position","text":"","category":"section"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"gate positions are specific with => at each line, the => operator inside function calls will not be parsed, e.g","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"1 => H # apply Hadamard gate on the 1st qubit\nfoo(1=>H) # it means normal Julia pair\n1=>foo(x, y, z) # it will parse foo(x, y, z) as a quantum gate/circuit, but will error later if type inference finds they are not.","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"all the gate or circuit's position should be specified by its complete locations, e.g","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"1:n => qft(n) # right\n1 => qft(n) # wrong","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"but single qubit gates can use multi-location argument to represent repeated locations, e.g","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"1:n => H # apply H on 1:n locations","category":"page"},{"location":"semantics/#Control","page":"Semantics","title":"Control","text":"","category":"section"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"@ctrl is parsed as a keyword (means you cannot overload it) in each program, like QBIR, its first argument is the control location with signs as control configurations and the second argument is a normal gate position argument introduce above.","category":"page"},{"location":"semantics/#Measure","page":"Semantics","title":"Measure","text":"","category":"section"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"@measure is another reserved special function parsed that has specific semantic in the IR (measure the locations passed to it).","category":"page"},{"location":"semantics/#Usage","page":"Semantics","title":"Usage","text":"","category":"section"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"using it is pretty simple, just use @device macro to annotate a \"device\" function, like CUDA programming, this device function should not return anything but nothing.","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"The compiler will compile this function definition to a generic circuit Circuit with the same name. A generic circuit is a generic quantum program that can be overload with different Julia types, e.g","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"@device function qft(n::Int)\n    1 => H\n    for k in 2:n\n        @ctrl k 1=>shift(2π/2^k)\n    end\n\n    if n > 1\n        2:n => qft(n-1)\n    end\nend","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"There is no need to worry about global position: everything can be defined locally and we will infer the correct global location later either in compile time or runtime.","category":"page"},{"location":"semantics/","page":"Semantics","title":"Semantics","text":"note: all the quantum gates should be annotate with its corresponding locations, or the compiler will not treat it as a quantum gate but instead of the original Julia expression.","category":"page"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"CurrentModule = YaoCompiler.Compiler","category":"page"},{"location":"compilation/#Compilation","page":"Compilation","title":"Compilation","text":"","category":"section"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"The compilation framework of YaoCompiler is designed to be highly extensible, so one can easily extend the semantics as long as there is no ambiguity.","category":"page"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"For simple code generation task, one can use Julia native macros directly instead of writing a custom compiler pass. But for more complicated task, one would prefer to add a custom compiler pass.","category":"page"},{"location":"compilation/#Representation","page":"Compilation","title":"Representation","text":"","category":"section"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"YaoCompiler is a domain specific language, it embeds its own representation inside the Julia AST and SSA IR.","category":"page"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"The Julia AST captured by a macro @device will be first transformed into custom function calls tagged with GlobalRef(YaoCompiler.Compiler, :node_name). The syntax check will then check if the syntax is correct, then the AST will be compiled into Julia's SSA IR as a CodeInfo object.","category":"page"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"Then we transform the CodeInfo object to a quantum SSA IR by inferring the quantum statements, where we call this representation as YaoIR.","category":"page"},{"location":"compilation/#YaoIR","page":"Compilation","title":"YaoIR","text":"","category":"section"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"The Yao IR annotates our domain specific semantics using a :quantum head, followed by a custom head, such as :gate. For example, 1 => X will be parsed as Expr(:quantum, :gate, :X, 1).","category":"page"},{"location":"compilation/#Compiler-API-References","page":"Compilation","title":"Compiler API References","text":"","category":"section"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"Modules = [YaoCompiler.Compiler]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = YaoCompiler.Compiler","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"YaoCompiler is a Julia compiler extension. It compiles a subset of Julia programs to quantum device. As a language aims to solve the two language problem, we want to provide our solution to the two language problem in quantum programming.","category":"page"},{"location":"","page":"Home","title":"Home","text":"YaoCompiler extends the native Julia semantics via macros and interpret these extra semantics via custom interpreter based on Julia's own interpreter during Julia's own type inference stage then runs our own specific optimization passes after Julia compiler optimizes the classical parts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The YaoCompiler project aims to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"compiles native Julia program to quantum devices and quantum device simulators\nprovide an infrastructure for quantum compilation related research.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Writing-Hybrid-Programs","page":"Home","title":"Writing Hybrid Programs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One of the major goal of YaoCompiler is to represent hybrid programs, which means programs mixed with classical functions and quantum routines. This is something happens very frequently in practical quantum computation and all the actual program controls quantum devices can be seen as such a hybrid program.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In YaoCompiler, you can use ANY classical Julia program semantics, such as control flows, function calls, and even other Julia packages. It is fully compatible with native Julia code. The compiler will only check if the program is compatible with your target machine or not. Here is a QFT example written using classical control flow:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@device function qft(n::Int)\n    1 => H\n    for k in 2:n\n        @ctrl k 1 => shift(2π / 2^k)\n    end\n\n    if n > 1\n        2:n => qft(n - 1)\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We don't have a real quantum device that supports running YaoCompiler natively, but ideally we can. Given Julia itself is actually Just-Ahead-of-Time (JAOT) compiled, there will not be any latency issue when we actually controls the quantum device - YaoCompiler as a subset of JuliaLang is static itself. It requires one to write type-stable Julia program in most cases except for native Julia simulator backend.","category":"page"},{"location":"#QASM-Support","page":"Home","title":"QASM Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can call QASM code like other Julia FFIs - simple and elegant:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> circuit = qasm\"\"\"OPENQASM 2.0;\n       include \"qelib1.inc\";\n       gate custom(lambda) a {\n           u1(sin(lambda) + 1) a;\n       }\n       // comment\n       gate g a\n       {\n           U(0,0,0) a;\n       }\n\n       qreg q[4];\n       creg c1[1];\n       U(-1.0, pi/2+3, 3.0) q[2];\n       CX q[1], q[2];\n       custom(0.3) q[3];\n       barrier q;\n       h q[0];\n       measure q[0] -> c1[0];\n       if(c1==1) z q[2];\n       u3(0.1 + 0.2, 0.2, 0.3) q[0];\n       \"\"\"\n##qasm#702 (generic routine with 1 methods)\n\njulia> YaoCompiler.@echo circuit()\n[ Info: executing 3 => Rz(-1.0)\n[ Info: executing 3 => Ry(4.570796326794897)\n[ Info: executing 3 => Rz(3.0)\n[ Info: executing @ctrl 2 3 => X\n[ Info: executing 4 => Rz(0)\n[ Info: executing 4 => Ry(0)\n[ Info: executing 4 => Rz(1.2955202066613396)\n[ Info: executing @barrier 1:4\n[ Info: executing 1 => H\n[ Info: executing @measure 1\n[ Info: executing 1 => Rz(0.30000000000000004)\n[ Info: executing 1 => Ry(0.2)\n[ Info: executing 1 => Rz(0.3)\n(c1 = 0,)","category":"page"},{"location":"","page":"Home","title":"Home","text":"this string literal @qasm_str (See string literal section of Julia documentation) will create a YaoCompiler routine for all the gate declaration and in the and creates a anoymous YaoCompiler routine for the toplevel QASM program.","category":"page"},{"location":"#Hybrid-Program-Optimization","page":"Home","title":"Hybrid Program Optimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"YaoCompiler can optimize your hybrid program using both Julia and its custom compiler optimization pass. See optimization section for more details.","category":"page"}]
}
