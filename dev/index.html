<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · YaoCompiler.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">YaoCompiler.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Features"><span>Features</span></a></li></ul></li><li><a class="tocitem" href="semantics/">Semantics</a></li><li><a class="tocitem" href="compilation/">Compilation</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumBFS/YaoCompiler.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>YaoCompiler is a <strong>Julia compiler extension</strong>. It compiles a subset of Julia programs to quantum device. As a language aims to solve the two language problem, we want to provide our solution to the two language problem in quantum programming.</p><p>YaoCompiler extends the native Julia semantics via macros and interpret these extra semantics via custom interpreter based on Julia&#39;s own interpreter during Julia&#39;s own type inference stage then runs our own specific optimization passes after Julia compiler optimizes the classical parts.</p><p>The YaoCompiler project aims to:</p><ol><li>compiles native Julia program to quantum devices and quantum device simulators</li><li>provide an infrastructure for quantum compilation related research.</li></ol><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><h3 id="Writing-Hybrid-Programs"><a class="docs-heading-anchor" href="#Writing-Hybrid-Programs">Writing Hybrid Programs</a><a id="Writing-Hybrid-Programs-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-Hybrid-Programs" title="Permalink"></a></h3><p>One of the major goal of YaoCompiler is to represent hybrid programs, which means programs mixed with classical functions and quantum routines. This is something happens very frequently in practical quantum computation and all the actual program controls quantum devices can be seen as such a hybrid program.</p><p>In YaoCompiler, you can use ANY classical Julia program semantics, such as control flows, function calls, and even other Julia packages. It is fully compatible with native Julia code. The compiler will only check if the program is compatible with your target machine or not. Here is a QFT example written using classical control flow:</p><pre><code class="language-julia">@device function qft(n::Int)
    1 =&gt; H
    for k in 2:n
        @ctrl k 1 =&gt; shift(2π / 2^k)
    end

    if n &gt; 1
        2:n =&gt; qft(n - 1)
    end
end</code></pre><p>We don&#39;t have a real quantum device that supports running YaoCompiler natively, but ideally we can. Given Julia itself is actually Just-Ahead-of-Time (JAOT) compiled, there will not be any latency issue when we actually controls the quantum device - YaoCompiler as a subset of JuliaLang is static itself. It requires one to write type-stable Julia program in most cases except for native Julia simulator backend.</p><h3 id="QASM-Support"><a class="docs-heading-anchor" href="#QASM-Support">QASM Support</a><a id="QASM-Support-1"></a><a class="docs-heading-anchor-permalink" href="#QASM-Support" title="Permalink"></a></h3><p>You can call QASM code like other Julia FFIs - simple and elegant:</p><pre><code class="language-julia">julia&gt; circuit = qasm&quot;&quot;&quot;OPENQASM 2.0;
       include &quot;qelib1.inc&quot;;
       gate custom(lambda) a {
           u1(sin(lambda) + 1) a;
       }
       // comment
       gate g a
       {
           U(0,0,0) a;
       }

       qreg q[4];
       creg c1[1];
       U(-1.0, pi/2+3, 3.0) q[2];
       CX q[1], q[2];
       custom(0.3) q[3];
       barrier q;
       h q[0];
       measure q[0] -&gt; c1[0];
       if(c1==1) z q[2];
       u3(0.1 + 0.2, 0.2, 0.3) q[0];
       &quot;&quot;&quot;
##qasm#702 (generic routine with 1 methods)

julia&gt; YaoCompiler.@echo circuit()
[ Info: executing 3 =&gt; Rz(-1.0)
[ Info: executing 3 =&gt; Ry(4.570796326794897)
[ Info: executing 3 =&gt; Rz(3.0)
[ Info: executing @ctrl 2 3 =&gt; X
[ Info: executing 4 =&gt; Rz(0)
[ Info: executing 4 =&gt; Ry(0)
[ Info: executing 4 =&gt; Rz(1.2955202066613396)
[ Info: executing @barrier 1:4
[ Info: executing 1 =&gt; H
[ Info: executing @measure 1
[ Info: executing 1 =&gt; Rz(0.30000000000000004)
[ Info: executing 1 =&gt; Ry(0.2)
[ Info: executing 1 =&gt; Rz(0.3)
(c1 = 0,)</code></pre><p>this string literal <code>@qasm_str</code> (See <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Non-Standard-String-Literals">string literal section of Julia documentation</a>) will create a YaoCompiler routine for all the gate declaration and in the and creates a anoymous YaoCompiler routine for the toplevel QASM program.</p><h3 id="Hybrid-Program-Optimization"><a class="docs-heading-anchor" href="#Hybrid-Program-Optimization">Hybrid Program Optimization</a><a id="Hybrid-Program-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Hybrid-Program-Optimization" title="Permalink"></a></h3><p>YaoCompiler can optimize your hybrid program using both Julia and its custom compiler optimization pass. See optimization section for more details.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="semantics/">Semantics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 1 May 2021 04:32">Saturday 1 May 2021</span>. Using Julia version 1.7.0-DEV.1046.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
