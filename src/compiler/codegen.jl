export codegen, JuliaASTCodegenCtx

abstract type CompileCtx end
abstract type AbstractJuliaASTCtx <: CompileCtx end

const codegen_passes = Dict{Symbol,Function}()

# abstract type AbstractQASMCtx <: CompileCtx end
# struct QASMCodegenCtx <: AbstractQASMCtx
#     codegen_pass::Vector{Any}
#     registers::Vector{Any}
# end

# function codegen(ctx::QASMCodegenCtx, ir::YaoIR)
#     lines = String[]
#     for pass in ctx.codegen_pass
#         push!(lines, codegen_passes[pass](ctx, ir))
#     end
#     return join(["// code generated by Yao",
#         "OPENQASM 2.0;", join(lines, ";\n"), "\n"], "\n")
# end

struct JuliaASTCodegenCtx <: AbstractJuliaASTCtx
    stub_name::Any
    circuit::Symbol
    registers::Vector{Any}
    locations::Symbol
    ctrl_locations::Symbol
    codegen_pass::Vector{Any}
end

# generate to JuliaAST by default
codegen(ir::YaoIR) = codegen(JuliaASTCodegenCtx(ir), ir)

function codegen(ctx::JuliaASTCodegenCtx, ir)
    ex = Expr(:block)
    for pass in ctx.codegen_pass
        push!(ex.args, codegen_passes[pass](ctx, ir))
    end

    if ir.name isa Symbol
        push!(ex.args, :($(ir.name)))
    else
        push!(ex.args, nothing)
    end
    return ex
end

macro codegen(ex)
    defs = splitdef(ex)
    defs[:name] isa Symbol ||
        throw(ParseError("@codegen expect function not callable or lambda function"))
    name = Symbol(:codegen_, defs[:name])
    quoted_name = QuoteNode(defs[:name])
    defs[:name] = name
    defs[:body] = quote
        @timeit_debug to $(string(name)) begin
            $(defs[:body])
        end
    end

    quote
        codegen_passes[$(quoted_name)] = $(esc(combinedef(defs)))
    end
end

flatten_locations(parent, x) = IRTools.xcall(Base, :getindex, parent, x)

function flatten_locations(pr, v, parent, x)
    loc = insert!(pr, v, Statement(to_locations(x)))
    return insert!(pr, v, Statement(flatten_locations(parent, loc)))
end

# merge location in runtime
merge_location_ex(l1, l2) = :(merge_locations($l1, $l2))
# merge literal location in compile time
merge_location_ex(l1::AbstractLocations, l2::AbstractLocations) = merge_locations(l1, l2)

function extract_closure_captured_variables!(pr::IRTools.Pipe, circ, ir::YaoIR)
    v = push!(pr, IRTools.xcall(Base, :getproperty, circ, QuoteNode(:free)))
    for (k, each) in enumerate(arguements(ir))
        x = push!(pr, IRTools.xcall(Base, :getfield, v, k))
        push!(pr, Statement(Expr(:(=), IRTools.Slot(each), x)))
    end
end

function scan_registers(register, stack::Vector, pr::IRTools.Pipe, v, st::Statement)
    if st.expr.args[2] === :new
        push!(stack, st.expr.args[3])
    elseif st.expr.args[2] === :prev
        pop!(stack)
    end

    if length(stack) == 1
        delete!(pr, v)
        return register
    else
        pr[v] = Statement(IRTools.Slot(first(stack)))
        return v
    end
end

@codegen function call(ctx::JuliaASTCodegenCtx, ir::YaoIR)
    @timeit_debug to "create defs" defs = signature(ir)
    if ir.name isa Symbol
        @timeit_debug to "create name" defs[:name] = :(::$(generic_circuit(ir.name)))
    end
    @timeit_debug to "create body" defs[:body] =
        Expr(:call, circuit(ir.name), ctx.stub_name, Expr(:tuple, arguements(ir)...))
    @timeit_debug to "combinedef" code = combinedef(defs)
    return code
end

@codegen function evaluate(ctx::JuliaASTCodegenCtx, ir::YaoIR)
    @timeit_debug to "create defs" defs = signature(ir)
    @timeit_debug to "create name" defs[:name] = GlobalRef(YaoLang, :evaluate)

    if ir.name isa Symbol
        @timeit_debug to "create args" defs[:args] = Any[:(::$(generic_circuit(ir.name))), ir.args...]
    else
        @timeit_debug to "create args" defs[:args] = Any[ir.name, ir.args...]
    end
    @timeit_debug to "create body" defs[:body] =
        Expr(:call, circuit(ir.name), ctx.stub_name, Expr(:tuple, arguements(ir)...))
    return combinedef(defs)
end

@codegen function circuit(ctx::JuliaASTCodegenCtx, ir::YaoIR)
    empty!(ctx.registers)
    pr = IRTools.Pipe(ir.body)
    circ = IRTools.argument!(pr)
    register = IRTools.argument!(pr)
    locations = IRTools.argument!(pr)

    # extract arguements from closure
    @timeit_debug to "extract variables" extract_closure_captured_variables!(pr, circ, ir)

    @timeit_debug to "IRTools.Pipe loop" for (v, st) in pr
        if is_quantum(st)
            head = st.expr.args[1]
            if head === :register
                register = scan_registers(register, ctx.registers, pr, v, st)
            elseif head in [:gate, :ctrl]
                locs = map(x -> flatten_locations(pr, v, locations, x), st.expr.args[3:end])
                pr[v] = Statement(st; expr = Expr(:call, st.expr.args[2], register, locs...))
            elseif head === :measure
                measure_ex = Expr(:call, GlobalRef(YaoAPI, :measure!))

                if (st.expr.args[2] isa Expr) && (st.expr.args[2].head === :parameters)
                    kwargs = first(st.expr.args[2])
                    if kwargs.args[1] === :reset_to
                        push!(measure_ex.args, Expr(:call, ResetTo, kwargs.args[2]))
                    elseif (kwargs.args[1] === :remove) && (kwargs.args[2] == true)
                        push!(measure_ex.args, Expr(:call, RemoveMeasured))
                    end
                    args = st.expr.args[3:end]
                else
                    args = st.expr.args[2:end]
                end

                # contains operator
                if length(args) == 2
                    push!(measure_ex.args, args[1])
                    push!(measure_ex.args, register)
                end

                push!(measure_ex.args, register)
                loc = flatten_locations(pr, v, locations, args[end])
                push!(measure_ex.args, loc)

                pr[v] = Statement(st; expr = measure_ex)
            else # reserved for extending keywords
                throw(ParseError("Invalid keyword: $head"))
            end
        end
    end

    def = Dict{Symbol,Any}()
    def[:name] = ctx.stub_name
    def[:args] = Any[
        :($(ctx.circuit)::$(YaoLang.Circuit)),
        :($(last(ctx.registers))::$AbstractRegister),
        :($(ctx.locations)::Locations),
    ]

    @timeit_debug to "IRTools.finish" ssa = IRTools.finish(pr)
    @timeit_debug to "build_codeinfo" code = build_codeinfo(ir.mod, def, ssa)
    return code
end

@codegen function ctrl_circuit(ctx::JuliaASTCodegenCtx, ir::YaoIR)
    if hasmeasure(ir)
        def = Dict{Symbol,Any}()
        def[:name] = ctx.stub_name
        def[:args] = Any[
            :($(ctx.circuit)::$(YaoLang.Circuit)),
            :($(gensym(:register))::$AbstractRegister),
            :($(ctx.locations)::$Locations),
            :($(ctx.ctrl_locations)::$CtrlLocations),
        ]
        def[:body] = quote
            error("cannot control quantum program contains measurement")
        end
        return combinedef(def)
    end

    empty!(ctx.registers)

    pr = IRTools.Pipe(ir.body)
    circ = IRTools.argument!(pr)
    register = IRTools.argument!(pr)
    locations = IRTools.argument!(pr)
    ctrl_locations = IRTools.argument!(pr)

    # extract arguements from closure
    @timeit_debug to "extract variables" extract_closure_captured_variables!(pr, circ, ir)

    @timeit_debug to "IRTools.Pipe loop" for (v, st) in pr
        if is_quantum(st)
            head = st.expr.args[1]
            if head === :register
                register = scan_registers(register, ctx.registers, pr, v, st)
            elseif head === :gate
                locs = flatten_locations(pr, v, locations, st.expr.args[3])
                pr[v] =
                    Statement(st; expr = Expr(:call, st.expr.args[2], register, locs, ctrl_locations))
            elseif head === :ctrl
                locs = flatten_locations(pr, v, locations, st.expr.args[3])
                ctrl_locs = flatten_locations(pr, v, locations, st.expr.args[4])
                ctrl_locs = insert!(pr, v, merge_location_ex(ctrl_locations, ctrl_locs))
                pr[v] = Statement(st; expr = Expr(:call, st.expr.args[2], register, locs, ctrl_locs))
            else # reserved for extending keywords
                throw(ParseError("Invalid keyword: $head"))
            end
        end
    end

    def = Dict{Symbol,Any}()
    def[:name] = ctx.stub_name
    def[:args] = Any[
        :($(ctx.circuit)::$(YaoLang.Circuit)),
        :($(last(ctx.registers))::$AbstractRegister),
        :($(ctx.locations)::$Locations),
        :($(ctx.ctrl_locations)::$CtrlLocations),
    ]

    @timeit_debug to "IRTools.finish" ssa = IRTools.finish(pr)
    @timeit_debug to "build_codeinfo" code = build_codeinfo(ir.mod, def, ssa)
    return code
end

@codegen function create_symbol(ctx::JuliaASTCodegenCtx, ir::YaoIR)
    # only create symbol when its a function declaration
    if ir.name isa Symbol
        :(Core.@__doc__ const $(ir.name) = $(generic_circuit(ir.name))())
    end
end

@codegen function code_yao_runtime_stub(ctx::JuliaASTCodegenCtx, ir::YaoIR)
    def = Dict{Symbol,Any}()
    def[:name] = GlobalRef(Compiler, :code_yao)
    def[:args] = Any[:(::$(generic_circuit(ir.name))), ir.args...]
    def[:body] = ir
    if !isempty(ir.whereparams)
        def[:whereparams] = ir.whereparams
    end
    return combinedef(def)
end

function JuliaASTCodegenCtx(ir::YaoIR, pass = collect(Any, keys(codegen_passes)))
    stub_name = gensym(rm_annotations(ir.name))
    JuliaASTCodegenCtx(
        stub_name,
        gensym(:circ),
        Any[gensym(:register)],
        gensym(:locations),
        gensym(:ctrl_locations),
        pass,
    )
end
